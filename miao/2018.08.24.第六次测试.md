大喵教育前端培训
================

## 阶段性测试 2018.08.24

### 大喵教育版权所有 | 出题人：谢然

01. 读程序写结果
    ```js
    var ary = [1,function(){console.log(this[0])}]
    console.log(ary[1]())
    ```
    ```js
    ary[1]()  => 1
    console.log(ary[1]()) => undefined
    ```

02. 读程序写结果
    ```js
    var obj = {
      a: 3,
      b: this.a * this.a
    }
    console.log(obj.b)          => NaN
    ```

03. 如何判断一个函数当前是否被当做构造函数调用？
```js
function Foo() {
    if (this instanceof Foo) {

    }

    if (new.target === Foo) {

    }
}
```

04. 什么叫做排序算法的稳定性？它有什么作用？
```js
指一个排序算法是否会改变排序前相同元素的相对位置

稳定的排序算法：基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序
不稳定：堆排序、快速排序、希尔排序、直接选择排序

作用：
    一个比较常用的地方是实现多级排序（级联排序），类似于成绩单中的总分相同按语文排，语文相同按数学排，以此类推

    使用稳定的排序只需要先按优先级最低的列排序，再依次往优先级高的列排序
```

05. 严格模式是什么？如何触发？有哪些限制？
```js
ECMAscript 5添加的严格模式，这种模式使得Javascript在更严格的条件下运行
消除了JavaScript语法的一些不合理，不严谨，减少了一些怪异行为
消除了代码运行的一些不安全，保证代码运行安全
提高便器效率，增加运行速度
为未来新版本的JavaScript做好铺垫

触发条件：'use strict'这条语句放在文件的第一行，或者函数的第一行，或者script标签的第一行

限制：变量必须先用var声明
      禁止使用with语句
      禁止删除变量
      不能重名
      限制了arguments
限制很多，最终的目的都是避免踩js坑
```

06. try catch finally 语句一般在什么情况下使用？有哪些需要注意的问题？最佳实践是什么？
```js
try语句允许我们定义在执行时进行错误测试的代码块
catch语句允许我们定义当try代码块发生错误时，所执行的代码块
finally语句在try和catch之后无论有无异常都会执行

在代码中有【可预料】的错误时使用

注意点：
1、只能捕获运行时错误，不能捕获语法错误（指不能捕获js代码本身的语法错误）
2、catch 和 finally语句都是可选的，但是在使用try语句时必须至少使用一个

try {
    tryCode - 尝试执行代码块
    throw "抛出错误信息"
}
catch(err) {
    catchCode - 捕获错误的代码块
}
finally {
    finallyCode - 无论 try / catch 结果如何都会执行的代码块
}

最佳实践：
    捕获到错误后一定要测试一下错误是不是自己期待的能够处理的错误类型的对象。
    切忌把错误完全隐藏
    如果错误不是自己所能处理的，应该再次抛出
```

07. 简述你对面向对象的三大特性的理解（不是把三大特性列出来）
```js
封装：
    把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。
    把与一个对象相关的数据及能对这些数据所能执行的操作放在一起
继承：
    可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行拓展。
    由于现实事物往往存在继承关系，我们希望某些类型的特性直接以某种形式获得其他类型的特性
多态：
    往往我们只需要事物某一方面的特性，此时只要给定的事物具有这个方面的特性，我们逻辑就能够走通。
    具体到程序中，就是只要某一个对象有特定的一组属性及方法即可，不需要它是特定类型的。

```

08. 解释一下你对构造函数的理解
```js
当new一个对象的时候，就会调用对应的构造函数，给对象赋予一些方法

构造函数的目的是为了初始化一个对象，
到后来是  通过给定的参数构造一个特定类型的对象。
即通过给定的参数设置表示该事物的对象上应有属性。

```

09. 如下代码的运行结果是什么？为什么？
    ```js
    var a = 8
    try {
        console.log(
    }

    => 以上代码有语法错误，通不过语法分析，不会运行起来。
    语法报错,'('后面应该是')'
    ```
10. 使用js语言实现如下功能
    ```js
    //传入表示fullName的字符串，包含两个单词
    var damiao = new Person('Xie Ran')

    console.log(damiao.firstName)//Xie
    console.log(damiao.lastName)//Ran

    damiao.fullName = 'Da Miao'

    console.log(damiao.firstName)//Da
    console.log(damiao.lastName)//Miao

    damiao.firstName = 'Xiao'

    console.log(damiao.fullName)// Xiao Miao
    ```

    ```js
    class Person {
        constructor(fullName) {
            var a = fullName.split(' ')
            this.firstName = a[0]
            this.lastName = a[1]
        }

        get fullName() {
            return this.firstName + ' ' + this.lastName
        }

        set fullName(name) {
            var a = name.split(' ')
            this.firstName = a[0]
            this.lastName = a[1]
        }
    }
    ```
11. 如何删除一个对象的某个属性？如何阻止一个对象的某个属性被删除？
```js
delete object.property


阻止对象属性被删除：
    Object.defineProperty(Object,'property',{
        configurable:false
    })

```

12. DOM结点的各种属性（property）和`get/setAttribute`有什么区别，联系和坑？
```js
property是指html文本被解析为对象后对象上的属性
attribute是指html文本中的html标签的属性

在一些情况下，同名的property和attribute是同步修改的
在另外一些情况下，是完全无关的
在还有一些情况下，是单向同步的

```

13. 为什么把一个DOM中已存在的结点插入到另一个位置会导致它在原来的位置自动消失？
```js
DOM结点是动态的
```

14. 使用var与使用let声明变量有什么区别？
```js
var定义的变量，它的作用于是在function或任何外部已经被声明的function，是全域的
let定义的变量，它的作用域是在一个块，不会被提升
```

15. 请分析快速排序算法的复杂度为；另分析使用快排变形算法找出乱序数组中第k大的数的复杂度
```

```

16. 如下程序以【何种方式】输出【何种结果】？
    ```js
    for(var i = 0; i<5; i++) {
      let j = i
      setTimeout(function(){
        console.log(j)   => 0,1,2,3,4
      }, 1000)
    }
    ```
17. 至少列出四种this在不同情况分别指向
```js
1、函数被当成某对象的方法调用，此时this指向该对象
2、函数通过call或apply调用，此时函数的this指向call/apply的第一个参数
3、函数被当成构造函数调用，此时this指向新创建的以本函数的prototype为原型的对象
4、函数被当成函数调用时，this指向window或undefined
5、函数被bind，返回的函数this总为被bind的值
6、箭头函数没有this（this对于箭头函数来说，是词法作用域变量）
7、getter/setter的this指向调用时的对象

```

18. 如何给一个已存在的对象添加getter/setter属性，写出代码。
```js
Object.defineProperty(Object.prototype,'self',{
    get: function(){
        return this
    }
})
```

19. 实现lodash的`forOwn`函数，用于遍历一个对象的自有属性
```js
function forOwn(obj,iterator){
    var hasOwn = Object.prototype.hasOwnPrototy
    for(var p in obj){
        if(hasOwn.call(obj,p)){
            if(iterator(obj[p],p,obj) === false){
                break
            }
        }
    }

    // var keys = Object.keys(obj)
    // for(var key of keys){
    //     if(iterator(obj[key],key,obj) === false){
    //         break
    //     }
    // }
}
```

20. 实现一个类【Quene】用以表达一个队列：
  * 队列是一种类似于数组的数据结构，但元素仅能从一边进入且仅能从另一边弹出队列，类似火车站
  * 设计良好的构造函数及接口以方便自己和他人使用
  * 至少需要实现的几个实例方法（其它方法按需实现）：
    * `Quene.prototype.next` 获取队列的下一个元素
    * `Quene.prototype.push` 将一个元素放进队列
    * `Quene.prorotype.length` 获取队列的长度（getter）
```js
function Quene(){
    this.arr = []
}
Quene.prototype.next = function(){

}
Quene.prototype.push = function(val){
    return this.arr.push(val)
}
Quene.prototype.length = function(){
    return this.arr.length
}
```

21. prototype与`__proto__`有什么区别和联系？
```js
我们通过函数定义了类Person，类（函数）自动获得属性prototype
每个类的实例都会有一个内部属性 __proto__ ，指向类的prototype属性

1\ 对象有属性 __proto__ ,指向该对象的构造函数的原型对象。
2\ 方法除了有属性 __proto__ ,还有属性prototype，prototype指向该方法的原型对象

区别：
    prototype是所有函数的一个自动获得的正常属性，其有一个不可枚举属性constructor指向函数本身
    __proto__每个对象都有的一个内部属性，它指向对象的原型（即在找不到自由属性时，会在原型上找）
联系：
    当一把个函数当成构造函数调用时，构造函数返回的对象的__proto__想象构造函数的prototype属性

```

22. 影响排序算法性能的本质原因是什么？
```js
排序其实是在改变原数组的逆序数
排序算法多数时候是在交换数组中元素的位置
所以影响效率的最大因素即为每一次交换对【逆序数】的改变
```

23. 如下数组按照经典算法就地调整成一个堆后的结果是什么样？
```js
    [3,5,1,1,2,8,9,0,7,4]  =>  [0,1,1,2,3,8,9,5,7,4]
```

24. 使用 new 调用一个函数时具体发生了什么？
```js
1、新建一个普通对象，把其原型 __proto__ 指向构造函数的 prototype 属性的值
2、生成一个新的执行上下文和对应的作用域，并把当前构造函数和两者关联起来
3、把这个执行上下文压入调用栈的顶部
4、把第一步生成的对象当做 this 的取值保存到作用域中的 environment recode 对象的内部属性 thisValue 中
5、执行函数体
6、把当前执行上下文弹出调用栈
7、处理函数执行的结果，即 new了之后返回的内容：
    - 如果步骤5返回一个对象，那么就把这个对象作为此次 new操作的返回值
    - 如果返回的不是对象，而且这个函数不是 generator 函数，那么返回第一步生成的对象
```

25. 什么叫做断言？它有什么用？一般用在什么地方？
```js
用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言

作用：
    一般是为了检测函数的参数是否符合要求，如果不符合，直接抛出错误
    写成一个断言函数是为了不必再每个需要检测参数的位置手动 if + throw 判断
```

26. DOM结点的innerHTML，innerText，textContent，outerHTML，outerText分别有什么区别？
```js
innerHTML
    返回HTML结构，会覆盖元素之前所有的内容，之前内容会被清空（所以之前如果有有绑定事件，则也一同消失）
innerText
    受CSS影响，返回文本内容
textContent
    不受CSS影响，完全是元素内部的所有文本结果的字符串的拼接
outerHTML   返回HTML结构（包含本身）
outerText   返回文本内容（包含本身）
```

27. 什么是属性描述符？如何获取一个对象某属性的属性描述符？
```js
对象是一个属性集合，对象的基本特征是属性名（name）和属性值（value）。
ES5 增加了属性描述符，可以更细腻的控制属性的不同操作。属性描述符有 configurable、writable 和 enumerable。

属性描述符通常和 Object.defineProperty/Object.defineProperties 一起使用来定义属性，它也会受到诸如 Object.freeze/Object.seal 等方法改变

```

28. 在去除癌症细胞一题中，为什么在正则的分支中，小c写前面也可以通过测试？
    ```js
    //即如下代码中，正则在替换掉第一个小c后，在继续往下扫描的过程中，为何没有替换掉xC？
    'abAaBxcCbcabc'.replace(/(c|[a-z]?C[a-z]?)/g, '')

    因为匹配到小c以后，下一次匹配从c的后面开始，在小c去掉之后左边的x不会被匹配上
    ```
29. 用正则表达式将以下字符串中不在双引号内的逗号变为“|”。
    ```js
    'foo,bar,baz,"damiao,xiaomiao",a,"b,c",d'

    ,(?=[^"](*"[^"]*")*[^"]*$)
    ```

30. 补全如下replace函数的调用使其将如下字符串中左边不是xx但右边是yy的OO替换为##.
    ```js
    'lskOOyydjfxxOOyyiwexxOOhayyOOxxlskdwOOyyflxxOOyykaxOOydfh'.replace(/(?<!xx)OO(?=yy)/g,'##')

    模拟回顾断言
    'lskOOyydjfxxOOyyiwexxOOhayyOOxxlskdwOOyyflxxOOyykaxOOydfh'.replace(/(?!xx)(..)OO(?=yy)/g,'$1##')
    ```

31. 画出以下正则表达式的铁路图
    ```js
    /^(-)?\d+(.\d{1,2})?$/
    ```

32. 写出与如下铁路图等价的正则表达式
    ![](reg-railway.png)

33. 双击以下代码渲染结果中一段话，会在控制台输出什么？并给出解释
    ```html
    <div>
      <p>Lorem ipsum dolor sit amet.</p>
    </div>
    <div>
      <p>dolor sit amet.</p>
    </div>
    <script>
      $('body').find('div').click(function(e) {
        console.log(e.target.tagName)
      }).dblclick(function(e) {
        console.log('div got double clicked')
      }).find('p').dblclick(function(e) {
        console.log(this.innerText)
        e.stopPropagation()
      }).end().end()
    </script>
    ```

34. 如下代码输出什么，解释原因并说明如何规避这种情况。
    ```js
    console.log(new Array(8).map((v,i) => i))

    new Array(8)产生了一个无数值属性的稀疏数组
    而数组上的大多数高阶方法都不会遍历数组的稀疏项
    ```

35. 说出无限滚动页面（类似花瓣、知乎，滚动到底部就继续加载）的实现思路，并写出大致伪代码
```js
当拉倒底部的时候触发加载事件
```

36. 哪些事件默认不会冒泡？
```js
blur
focus
onload
onerror
mouseenter
mouseleave

每个event都有一个event.bubbles属性

media相关事件都不冒泡

abort	            ✗
beforeinput         ✔
blur	            ✗
click	            ✔
compositionstart    ✔
compositionupdate   ✔
compositionend      ✔
dblclick            ✔
error	            ✗
focus	            ✗
focusin	            ✔
focusout            ✔
input	            ✔
keydown	            ✔
keyup	            ✔
load	            ✗
mousedown           ✔
mouseenter          ✗
mouseleave          ✗
mousemove           ✔
mouseout            ✔
mouseover           ✔
mouseup	            ✔
resize	            ✗
scroll	            ✔
select	            ✔
unload	            ✗
wheel	            ✔
```

37. 写出优化大型页面滚动过程的代码：
    * 将不在视口区域内的内容从DOM中移除
    * 将在视口区域的内容显示出来
    * 但是不能让它们的隐藏或显示影响页面布局
    * 具体的隐藏方式可任意
```js

```

38. 什么是多重转义，在什么时候会用到？使用合适的语言描述出来。
```js
当用一种语言表达另一种需要转义的内容时，可能涉及到多重转义

onclick="alert(&apos;hello&apos;)"

new RegExp('\\d+')
```

39. 什么是正则表达式中的零宽断言？并举出至少两个使用场景。
```js
断言某个位置的左边(lookbehind)或者右边(lookahead)满足(postive)或者不满足(negative)某个条件。

(?=expr) 正预测 断言某个位置的右边满足expr
(?!expr) 负预测 断言某个位置的右边不满足expr
(?<=expr) 正回顾 断言某个位置的左边满足expr
(?<!expr) 负回顾 断言某个位置的左边不满足expr
```

40. 分别说出以下几个与正则相关的函数的【各种】用法及效果，可以查文档
    * String.prototype.replace
    * String.prototype.search
    * String.prototype.match
    * RegExp.prototype.test
    * RegExp.prototype.exec
```js
str.replace(regexp,''):
    将正则表达式匹配到的内容，替换为第二个参数的内容
str.search(regexp):
    若匹配成功，返回正则表达式在字符串中首次匹配项的索引，否则返回-1
str.match(regexp):
    若匹配成功，会返回一个数组，数组的第一项是进行匹配完整的字符串，之后的项是用圆括号捕获的结果。如果没有匹配到，返回null
regexObj.test(str):
    用于查看正则表达式与指定的字符串是否匹配，返回true或false
regexObj.exec(str):
    在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null
```

41. HTML、JS、正则表达式、URL encode、CSS等的转义符分别是什么
```js
HTML:
    &xxx
JS：
    \
    \u{}
    \u6211
正则：
    同js
URL编码：
    %
CSS：
    \A
```

42. 什么是vanilla.js？
```

```

43. 为字符串对象增加一个方法replaceAll（wildcard，target），讨论poilfill
    * 其中wildcard为一个表示通配符的字符串
    * target可以为一个字符串，也可以为一个函数
        * 如果是一个字符串，则把所有匹配到的内容替换为该字符串
        * 如果为一个函数，则把每一个匹配得到的内容传给该函数，并将该函数的返回值做为被替换的内容
```

```

44. 描述正则表达式的匹配过程
```
回溯
```

45. 如何阻止事件冒泡？如何阻止浏览器对某些事件的默认行为？如果模拟用户的点击事件？
```js
阻止冒泡：
    e.stopPropagation()
阻止默认行为：
    e.preventDefault()

https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events
```

46. 什么是事件代理？
```js
事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown......） 的函数委托到另一个元素； 一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。

利用事件的冒泡或捕获，让祖先元素来处理后代元素的事件的做法就是事件代理。
好处：
    事件不用绑定在每个后代元素上，节省了内存，后代元素可以频繁发生变化
```

47. 给元素绑定事件处理函数有多少种方式？每种方式各有什么优缺点？
```js
1、在DOM元素中直接绑定
    <input onclick="do something"/>

2、在JavaScript代码中绑定
    el.onclick = fn

以上两种办法只能注册冒泡阶段的事件

3、绑定事件监听函数
    el.addEventListener('click',fn)

以上方法可以注册冒泡和捕获阶段的事件

```

48. 如何阻止事件的默认行为？哪些事件的默认行为无法阻止？应对方案是什么？
```js
阻止默认行为：
    e.preventDefault()

无法阻止的事件默认行为：
    scroll
    onclose
    换用其他类似的事件或者

```

49. mouseover与mouseout事件有什么需要注意的问题？
```js
它们会冒泡
鼠标从父元素移到子元素上时，父元素的mouseout也会触发
当鼠标进入元素的时候会先触发mouseout事件，然后再触发mouseover事件

```

50. debounce与trottle函数的适用场景有什么不同？
```js
一般来说，事件频繁触发，只需要在最后一次执行一下，用debounce

事件频繁触发，只是不需要频繁触发，用throttle
```

51. 说出尽量多不那么常见的事件
```js
禁止鼠标右键：oncontextmenu="return false"
禁止选择：onselectstart="return false"
禁止拖放：ondragstart="return false"
禁止拷贝：oncopy = document.selection.empty()
禁止复制：oncopy = "return false"
禁止粘贴：onpaste = "return false"
禁止剪贴：oncut = "return false"
禁止保存：<noscript><iframe src="*.htm"></iframe></noscript>，放在head里面
关闭输入法：<input style="ime-mode:disabled">
```

52. 什么叫token？将如下代码中的token写成一个js数组
```js
    const {Readable, Writable} = require('stream')
    while(true) {
        console.log(1)
    }
```
